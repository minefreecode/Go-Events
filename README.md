# Организация событийного круга в GO

Алгоритм:
1. Создать каналы по которым будет передаваться событие. На каждый канал только событие одного типа. Хотя можно передавать
и по одному каналу но в таком случае придётся различать тип события. Нужно сделать это в основном потоке программы
```GO
	userEvents := make(chan string, 10)   // Создание канала пользовательских событий
	systemEvents := make(chan string, 10) //Создание канала системных событий
	timerEvents := make(chan string, 10)  //Канал событий тайминга
	shutdown := make(chan struct{})       //Канал для событий закртия программы
```

2. Написать обработчики событий в виде `select` в отдельной подпрограмме
```go
	for {
		select {
		case event := <-userEvents:
			fmt.Printf("Обработка событий пользователя: %s\n", event)
			processUserEvent(event)
		case event := <-systemEvents:
			fmt.Printf("Обработка системного события: %s\n", event)
			processSystemEvent(event)
		case event := <-timerEvents:
			fmt.Printf("Обработка событий тайминга: %s\n", event)
			processTimerEvent(event)
		case <-shutdown:
			fmt.Println("Событие закртытия получено")
			return
		}

	}
```
`Case` возникает когда на канал приходит любое текстовое сообщение. В случае с одним каналом нужео будет различать тип события в тексте
и вызывать соответствующий `case`. Из пунктов ``Case`` будут вызываться обработчики

3. Написать продьюсеры событий. Предполагается что продьюсеры будут находиться в отдельной подпрограмме.
Генерация нового события в подпрограммах будет выгладеть так:
Входной параметр в функции:
```go
events chan<- string
```

```go
events <- fmt.Sprintf("%s (user_%d)", action, i+1)
```

